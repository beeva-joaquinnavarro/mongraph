// Generated by CoffeeScript 1.6.2
var config, constructorNameOf, init, mongraphMongoosePlugin, processtools, registerModels, _;

processtools = require('./processtools');

mongraphMongoosePlugin = require('./mongraphMongoosePlugin');

_ = require('underscore');

constructorNameOf = processtools.constructorNameOf;

config = {
  options: {
    collectionToModel: {}
  }
};

registerModels = function(mongoose) {
  var collection, modelName, models, _ref;

  if (constructorNameOf(mongoose) === 'Mongoose') {
    models = mongoose.models;
  } else if (!mongoose) {
    throw new Error('Expecting a mongoose- or a mongoose.models-object for registration');
  } else {
    models = mongoose;
  }
  for (modelName in models) {
    _ref = models[modelName], collection = _ref.collection, modelName = _ref.modelName;
    config.options.collectionToModel[collection.name] = modelName;
  }
  return config.options.collectionToModel;
};

init = function(options) {
  var functionName, node, _base, _base1, _base2, _base3, _base4, _base5, _base6, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;

  if (typeof options !== 'object') {
    options = {};
  }
  _.extend(config.options, options);
  config.mongoose = options.mongoose;
  config.graphdb = options.neo4j;
  if ((_ref = (_base = config.options).overwriteProtypeFunctions) == null) {
    _base.overwriteProtypeFunctions = false;
  }
  if ((_ref1 = (_base1 = config.options).storeDocumentInGraphDatabase) == null) {
    _base1.storeDocumentInGraphDatabase = false;
  }
  if ((_ref2 = (_base2 = config.options).cacheNodes) == null) {
    _base2.cacheNodes = true;
  }
  if ((_ref3 = (_base3 = config.options).loadMongoDBRecords) == null) {
    _base3.loadMongoDBRecords = true;
  }
  if ((_ref4 = (_base4 = config.options).extendSchemaWithMongoosePlugin) == null) {
    _base4.extendSchemaWithMongoosePlugin = true;
  }
  if ((_ref5 = (_base5 = config.options).relationships) == null) {
    _base5.relationships = {};
  }
  config.options.relationships.storeTimestamp = true;
  config.options.relationships.storeIDsInRelationship = true;
  if ((_ref6 = (_base6 = config.options.relationships).bidirectional) == null) {
    _base6.bidirectional = false;
  }
  if (constructorNameOf(config.mongoose) !== 'Mongoose') {
    throw new Error("mongraph needs a mongoose reference as parameter");
  }
  if (constructorNameOf(config.graphdb) !== 'GraphDatabase') {
    throw new Error("mongraph needs a neo4j graphdatabase reference as paramater");
  }
  if (config.options.overwriteProtypeFunctions !== true) {
    _ref7 = ["getRelationships", "createRelationshipTo", "deleteRelationshipTo", "getNode", "findEquivalentNode", "findOrCreateEquivalentNode", "getRelatedDocuments", "_graph"];
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      functionName = _ref7[_i];
      if (typeof config.mongoose.Document.prototype[functionName] !== 'undefined') {
        throw new Error("Will not override mongoose::Document.prototype." + functionName);
      }
    }
    node = config.graphdb.createNode();
    _ref8 = ["getCollectionName", "getMongoId"];
    for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
      functionName = _ref8[_j];
      if (typeof node.constructor.prototype[functionName] !== 'undefined') {
        throw new Error("Will not override neo4j::Node.prototype." + functionName);
      }
    }
  }
  require('./extendDocument')(config.mongoose, config.graphdb, config.options);
  require('./extendNode')(config.graphdb, config.mongoose, config.options);
  if (config.options.extendSchemaWithMongoosePlugin) {
    return config.mongoose.plugin(mongraphMongoosePlugin);
  }
};

module.exports = {
  init: init,
  config: config,
  processtools: processtools,
  registerModels: registerModels
};
