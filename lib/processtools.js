// Generated by CoffeeScript 1.6.2
var Join, ObjectId, constructorNameOf, extractCollectionAndId, getCollectionByCollectionName, getModelByCollectionName, getMongoose, getNeo4j, getObjectIDAsString, getObjectIDsAsArray, getObjectIdFromString, mongoose, neo4j, populateResultWithDocuments, setMongoose, setNeo4j, sortJoins, sortOptionsAndCallback, _buildQueryFromIdAndCondition;

ObjectId = require('bson').ObjectID;

Join = require('join');

mongoose = null;

neo4j = null;

setMongoose = function(mongooseHandler) {
  return mongoose = mongooseHandler;
};

getMongoose = function() {
  return mongoose;
};

setNeo4j = function(neo4jHandler) {
  return neo4j = neo4jHandler;
};

getNeo4j = function() {
  return neo4j;
};

sortOptionsAndCallback = function(options, cb) {
  if (typeof options === 'function') {
    return {
      options: {},
      cb: options
    };
  } else {
    return {
      options: options || {},
      cb: cb
    };
  }
};

sortJoins = function(args) {
  var arg, returns, _i, _len;

  args = Array.prototype.slice.call(args);
  returns = {
    errors: [],
    result: []
  };
  for (_i = 0, _len = args.length; _i < _len; _i++) {
    arg = args[_i];
    if (arg[0]) {
      returns.errors.push(arg[0]);
    }
    if (arg[1]) {
      returns.errors.push(arg[1]);
    }
  }
  returns.errors = returns.errors.length > 0 ? new Error(returns.errors.join(", ")) : null;
  returns.result = returns.result.length > 0 ? returns.result : null;
  return returns;
};

constructorNameOf = function(f) {
  var _ref, _ref1, _ref2;

  return (f != null ? (_ref = f.constructor) != null ? (_ref1 = _ref.toString().match(/function\s+(.+?)\(/)) != null ? (_ref2 = _ref1[1]) != null ? _ref2.trim() : void 0 : void 0 : void 0 : void 0) || null;
};

extractCollectionAndId = function(s) {
  var parts;

  if ((parts = s.split(":"))) {
    return {
      collectionName: parts[0],
      _id: parts[1]
    };
  }
};

_buildQueryFromIdAndCondition = function(_id_s, condition) {
  var idCondition, _ref;

  if ((_id_s != null ? _id_s.constructor : void 0) === Array) {
    idCondition = {
      _id: {
        $in: _id
      }
    };
  } else if (_id_s) {
    idCondition = {
      Â _id: String(_id_s)
    };
  } else {
    return {};
  }
  if (typeof condition === 'object' && condition && ((_ref = Object.keys(condition)) != null ? _ref.length : void 0) > 0) {
    return {
      $and: [idCondition, condition]
    };
  } else {
    return idCondition;
  }
};

getObjectIDAsString = function(obj) {
  if (typeof obj === 'string') {
    return obj;
  } else if (typeof obj === 'object') {
    return String(obj._id || obj);
  } else {
    return '';
  }
};

getObjectIdFromString = function(s) {
  return new ObjectId(s);
};

getObjectIDsAsArray = function(mixed) {
  var id, ids, item, _i, _len;

  ids = [];
  if ((mixed != null ? mixed.constructor : void 0) === Array) {
    for (_i = 0, _len = mixed.length; _i < _len; _i++) {
      item = mixed[_i];
      if (id = getObjectIDAsString(item)) {
        ids.push(id);
      }
    }
  } else {
    ids = [getObjectIDAsString(mixed)];
  }
  return ids;
};

getModelByCollectionName = function(collectionName, mongoose) {
  var i, models, name, nameOfModel;

  if (constructorNameOf(mongoose) === 'Mongoose') {
    models = mongoose.models;
  } else if (!mongoose) {
    return null;
  } else {
    models = mongoose;
  }
  name = null;
  for (nameOfModel in models) {
    i = models[nameOfModel];
    if (collectionName === models[nameOfModel].collection.name) {
      name = models[nameOfModel].modelName;
    }
  }
  return name;
};

getCollectionByCollectionName = function(collectionName, mongoose) {
  var modelName, _ref;

  modelName = getModelByCollectionName(collectionName, mongoose);
  return mongoose.models[modelName] || ((_ref = mongoose.connections[0]) != null ? _ref.collection(collectionName) : void 0) || mongoose.collection(collectionName);
};

populateResultWithDocuments = function(results, options, cb) {
  var final, graphdb, i, join, path, result, _base, _fn, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

  _ref = sortOptionsAndCallback(options, cb), options = _ref.options, cb = _ref.cb;
  if ((_ref1 = options.count) == null) {
    options.count = false;
  }
  if ((_ref2 = options.restructure) == null) {
    options.restructure = true;
  }
  if ((_ref3 = options.referenceDocumentID) == null) {
    options.referenceDocumentID = null;
  }
  if (options.referenceDocumentID) {
    options.referenceDocumentID = String(options.referenceDocumentID);
  }
  if ((_ref4 = options.collection) == null) {
    options.collection = null;
  }
  if ((_ref5 = options.where) == null) {
    options.where = null;
  }
  options.debug = options.debug ? {} : null;
  if ((_ref6 = options.stripEmptyItems) == null) {
    options.stripEmptyItems = true;
  }
  if (options.debug) {
    if ((_ref7 = (_base = options.debug).where) == null) {
      _base.where = [];
    }
  }
  if (!(results instanceof Object)) {
    return cb(new Error('Object is needed for processing'), null, options);
  } else if (!(results instanceof Array)) {
    results = [results];
  }
  final = function(err) {
    var cleanedResults, result, _i, _len;

    if (options.restructure && (typeof path !== "undefined" && path !== null ? path.length : void 0) > 0) {
      results = path;
    }
    if (options.stripEmptyItems && (results != null ? results.length : void 0) > 0) {
      cleanedResults = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        if (result != null) {
          cleanedResults.push(result);
        }
      }
      return cb(null, cleanedResults, options);
    } else {
      return cb(null, results, options);
    }
  };
  mongoose = getMongoose();
  graphdb = getNeo4j();
  path = null;
  join = Join.create();
  _fn = function(result, i) {
    var callback, collection, conditions, fromAndToJoin, intermediateCallback, isReferenceDocument, k, node, point, _fn1, _j, _k, _len1, _len2, _p, _ref10, _ref11, _ref12, _ref13, _ref14, _ref8, _ref9, _results;

    if (constructorNameOf(result) === 'Node' && ((_ref8 = result.data) != null ? _ref8.collection : void 0) && ((_ref9 = result.data) != null ? _ref9._id : void 0)) {
      callback = join.add();
      isReferenceDocument = options.referenceDocumentID === result.data._id;
      if (options.collection && options.collection !== result.data.collection) {
        return callback(err, results);
      } else {
        conditions = _buildQueryFromIdAndCondition(result.data._id, !isReferenceDocument ? options.where : void 0);
        if (options.debug) {
          options.debug.where.push(conditions);
        }
        collection = getCollectionByCollectionName(result.data.collection, mongoose);
        return collection.findOne(conditions, function(err, foundDocument) {
          results[i].document = foundDocument;
          return callback(err, results);
        });
      }
    } else if (constructorNameOf(result) === 'Relationship' && ((_ref10 = result.data) != null ? _ref10._from : void 0) && ((_ref11 = result.data) != null ? _ref11._to : void 0)) {
      callback = join.add();
      fromAndToJoin = Join.create();
      _ref12 = ['from', 'to'];
      _fn1 = function(point, intermediateCallback) {
        var collectionName, _id, _ref13;

        _ref13 = extractCollectionAndId(result.data["_" + point]), collectionName = _ref13.collectionName, _id = _ref13._id;
        isReferenceDocument = options.referenceDocumentID === _id;
        if (options.collection && options.collection !== collectionName && !isReferenceDocument) {
          results[i] = null;
          return intermediateCallback(null, null);
        } else {
          conditions = _buildQueryFromIdAndCondition(_id, !isReferenceDocument ? options.where : void 0);
          if (options.debug) {
            options.debug.where.push(conditions);
          }
          collection = getCollectionByCollectionName(collectionName, mongoose);
          return collection.findOne(conditions, function(err, foundDocument) {
            if (foundDocument && results[i]) {
              results[i][point] = foundDocument;
            } else {
              results[i] = null;
            }
            return intermediateCallback(null, null);
          });
        }
      };
      for (_j = 0, _len1 = _ref12.length; _j < _len1; _j++) {
        point = _ref12[_j];
        intermediateCallback = fromAndToJoin.add();
        _fn1(point, intermediateCallback);
      }
      return fromAndToJoin.when(function() {
        return callback(null, null);
      });
    } else if (constructorNameOf(result) === 'Path' || constructorNameOf(result.p) === 'Path') {
      _p = result.p || result;
      results[i].path = Array(_p._nodes.length);
      path = options.restructure ? Array(_p._nodes.length) : void 0;
      _ref13 = _p._nodes;
      _results = [];
      for (k = _k = 0, _len2 = _ref13.length; _k < _len2; k = ++_k) {
        node = _ref13[k];
        if ((_ref14 = node._data) != null ? _ref14.self : void 0) {
          callback = join.add();
          _results.push((function(k, callback) {
            return graphdb.getNode(node._data.self, function(err, foundNode) {
              var collectionName, _id, _ref15;

              if (foundNode != null ? (_ref15 = foundNode.data) != null ? _ref15._id : void 0 : void 0) {
                isReferenceDocument = options.referenceDocumentID === foundNode.data._id;
                collectionName = foundNode.data.collection;
                _id = foundNode.data._id;
                if (options.collection && options.collection !== collectionName && !isReferenceDocument) {
                  return callback(null, path || results);
                } else {
                  conditions = _buildQueryFromIdAndCondition(_id, options.where);
                  if (options.debug) {
                    options.debug.where.push(conditions);
                  }
                  collection = getCollectionByCollectionName(collectionName, mongoose);
                  return collection.findOne(conditions, function(err, foundDocument) {
                    if (options.restructure) {
                      path[k] = foundDocument;
                    } else {
                      results[i].path[k] = foundDocument;
                    }
                    return callback(null, path || results);
                  });
                }
              } else {
                if (options.restructure) {
                  path[k] = null;
                } else {
                  results[i].path[k] = null;
                }
                return callback(null, path || results);
              }
            });
          })(k, callback));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    } else {
      return final(new Error("Could not detect given result type"), null);
    }
  };
  for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
    result = results[i];
    _fn(result, i);
  }
  return join.when(function() {
    var error, _ref8;

    _ref8 = sortJoins(arguments), error = _ref8.error, result = _ref8.result;
    return final(error, null);
  });
};

module.exports = {
  populateResultWithDocuments: populateResultWithDocuments,
  getObjectIDAsString: getObjectIDAsString,
  getObjectIDsAsArray: getObjectIDsAsArray,
  constructorNameOf: constructorNameOf,
  getObjectIdFromString: getObjectIdFromString,
  sortOptionsAndCallback: sortOptionsAndCallback,
  getModelByCollectionName: getModelByCollectionName,
  getCollectionByCollectionName: getCollectionByCollectionName,
  setMongoose: setMongoose,
  setNeo4j: setNeo4j,
  extractCollectionAndId: extractCollectionAndId,
  ObjectId: ObjectId
};
